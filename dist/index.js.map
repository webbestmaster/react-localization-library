{"version":3,"file":"index.js","mappings":"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","sources":["webpack://react-localization-library/webpack/bootstrap","webpack://react-localization-library/webpack/runtime/define property getters","webpack://react-localization-library/webpack/runtime/hasOwnProperty shorthand","webpack://react-localization-library/webpack/runtime/make namespace object","webpack://react-localization-library/external commonjs \"react/jsx-runtime\"","webpack://react-localization-library/external commonjs \"react\"","webpack://react-localization-library/./www/library/src/localization-const.ts","webpack://react-localization-library/./www/library/src/localization-helper.tsx","webpack://react-localization-library/./www/library/src/localization.tsx","webpack://react-localization-library/./www/library/src/util/timer.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"react/jsx-runtime\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"react\");","// eslint-disable-next-line optimize-regex/optimize-regex\nexport const splitValueStringRegExp = /(?=\\{\\w+?\\})/gu;\n\nexport const placeholderText = \"_TEXT_\";\n","/* eslint-disable multiline-comment-style, capitalized-comments, line-comment-position, multiline-comment-style */\n\nimport {Fragment, type ReactNode} from \"react\";\n\nimport {splitValueStringRegExp} from \"./localization-const\";\nimport type {LocalizationDataType, LocalizationType, RawLocalizationDataType} from \"./localization-type\";\n\nfunction replacePlaceholderMap(rawString: string, valueMap: Readonly<Record<string, string>>): string {\n    let resultString = rawString;\n\n    const keyList = Object.keys(valueMap);\n\n    // eslint-disable-next-line no-loops/no-loops\n    for (const objectKey of keyList) {\n        resultString = resultString.replace(new RegExp(`\\\\{${objectKey}\\\\}`, \"gu\"), valueMap[objectKey]);\n    }\n\n    return resultString;\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nexport function getLocalizedString<TranslationKeys extends string, LocaleName extends string>(\n    stringKey: TranslationKeys,\n    localeName: LocaleName,\n    localization: LocalizationDataType<TranslationKeys>,\n    valueMap?: Readonly<Record<string, string>>\n): string {\n    // const localizationData = localization[localeName];\n\n    // if (typeof localizationData === 'function') {\n    //     return 'TEXT';\n    // }\n\n    const resultString = localization[stringKey];\n\n    return valueMap ? replacePlaceholderMap(resultString, valueMap) : resultString;\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nexport function getLocalizedComponentHelper<TranslationKeys extends string, LocaleName extends string>(\n    stringKey: TranslationKeys,\n    localeName: LocaleName,\n    localization: LocalizationDataType<TranslationKeys>,\n    valueMap: Record<string, ReactNode>\n): Array<JSX.Element | string> {\n    const resultString = localization[stringKey]; // 'the {value1} data {value2} is {value2} here'\n\n    let partList: Array<JSX.Element | string> = resultString.split(splitValueStringRegExp); // [\"the \", \"{value1} data \", \"{value2} is \", \"{value2} here\"]\n\n    const keyList = Object.keys(valueMap);\n\n    // eslint-disable-next-line no-loops/no-loops\n    for (const objectKey of keyList) {\n        partList = partList.map((part: Readonly<JSX.Element> | string, index: number): JSX.Element | string => {\n            if (typeof part !== \"string\") {\n                return part;\n            }\n\n            const replacedPart = `{${objectKey}}`;\n\n            if (!part.startsWith(replacedPart)) {\n                return part;\n            }\n\n            const endOfString = part.slice(replacedPart.length);\n\n            return (\n                <Fragment key={String(`${objectKey}-${index}`)}>\n                    {valueMap[objectKey]}\n                    {endOfString}\n                </Fragment>\n            );\n        });\n    }\n\n    return partList;\n}\n\nexport async function fetchLocalizationData<LocaleName extends string, TranslationKeys extends string>(\n    localeName: LocaleName,\n    localization: LocalizationType<LocaleName, TranslationKeys>\n): Promise<LocalizationDataType<TranslationKeys>> {\n    const localizationData: RawLocalizationDataType<TranslationKeys> = localization[localeName];\n\n    if (typeof localizationData === \"function\") {\n        return localizationData();\n    }\n\n    return localizationData;\n}\n","/* eslint-disable react/no-multi-comp */\nimport {type Context, createContext, useCallback, useContext, useEffect, useMemo, useState} from \"react\";\n\nimport type {\n    LocaleContextType,\n    LocalePropsType,\n    LocalizationConfigType,\n    LocalizationLibraryType,\n    ProviderPropsType,\n} from \"../library\";\n\nimport {\n    fetchLocalizationData,\n    getLocalizedComponentHelper,\n    getLocalizedString as getLocalizedStringHelper,\n} from \"./localization-helper\";\nimport type {LocalizationDataType, LocalizationType, RawLocalizationDataType} from \"./localization-type\";\nimport {placeholderText} from \"./localization-const\";\nimport {waitForTime} from \"./util/timer\";\n\nexport function createLocalization<TranslationKeys extends string, LocaleName extends string>(\n    localizationConfig: LocalizationConfigType<TranslationKeys, LocaleName>\n): LocalizationLibraryType<TranslationKeys, LocaleName> {\n    const {\n        defaultLocaleName,\n        localization: localizationArgument,\n        onUseEffect = (): void => {\n            // eslint-disable-next-line no-undefined\n            return undefined;\n        },\n    } = localizationConfig;\n    let previousLocalizationName: LocaleName = defaultLocaleName;\n\n    const localization: LocalizationType<LocaleName, TranslationKeys> = {...localizationArgument};\n\n    const defaultLocalizationData: LocaleContextType<TranslationKeys, LocaleName> = {\n        // eslint-disable-next-line @typescript-eslint/unbound-method, jest/unbound-method\n        getLocalizedString: String.toString,\n        isFetchingLocaleData: typeof localization[defaultLocaleName] === \"function\",\n        localeName: defaultLocaleName,\n        // eslint-disable-next-line @typescript-eslint/unbound-method, jest/unbound-method\n        setLocaleName: String.toString,\n    };\n\n    const LocaleContext: Context<LocaleContextType<TranslationKeys, LocaleName>> =\n        createContext<LocaleContextType<TranslationKeys, LocaleName>>(defaultLocalizationData);\n\n    function LocalizationProvider(props: ProviderPropsType<LocaleName>): JSX.Element {\n        const {children, forcedLocaleName} = props;\n\n        const [localeName, setLocaleName] = useState<LocaleName>(\n            forcedLocaleName ?? defaultLocalizationData.localeName\n        );\n        const [isFetchingLocaleData, setIsFetchingLocaleData] = useState<boolean>(\n            defaultLocalizationData.isFetchingLocaleData\n        );\n\n        useEffect(() => {\n            if (typeof forcedLocaleName === \"string\" && forcedLocaleName.trim() !== \"\") {\n                setLocaleName(forcedLocaleName);\n            }\n        }, [forcedLocaleName]);\n\n        useEffect(() => {\n            const existsLocalizationData: RawLocalizationDataType<TranslationKeys> = localization[localeName];\n\n            // Check localization data already exists\n            if (typeof existsLocalizationData !== \"function\") {\n                previousLocalizationName = localeName;\n                onUseEffect({isFetchingLocaleData: false, localeName});\n                return;\n            }\n\n            setIsFetchingLocaleData(true);\n            onUseEffect({isFetchingLocaleData: true, localeName: previousLocalizationName});\n\n            // eslint-disable-next-line promise/catch-or-return, @typescript-eslint/no-floating-promises\n            fetchLocalizationData<LocaleName, TranslationKeys>(localeName, localization)\n                .then(async (localizationData: LocalizationDataType<TranslationKeys>) => {\n                    // Make sure that React's circle is updated, needed to update async locale\n                    // eslint-disable-next-line promise/no-nesting\n                    return waitForTime(0).then(() => {\n                        localization[localeName] = localizationData;\n                        previousLocalizationName = localeName;\n\n                        onUseEffect({isFetchingLocaleData: false, localeName});\n                    });\n                })\n                .finally((): void => {\n                    setIsFetchingLocaleData(false);\n                });\n        }, [localeName, setIsFetchingLocaleData]);\n\n        const memoizedSetLocaleName = useCallback(\n            (updatedLocaleName: LocaleName) => {\n                if (isFetchingLocaleData) {\n                    console.log(\"do not change locale name while localizing data loading\");\n                    return;\n                }\n                setLocaleName(updatedLocaleName);\n            },\n            [isFetchingLocaleData]\n        );\n\n        const getLocalizedString = useCallback(\n            (stringKey: Readonly<TranslationKeys>, valueMap?: Readonly<Record<string, string>>): string => {\n                const existsLocalizationData: RawLocalizationDataType<TranslationKeys> = localization[localeName];\n                const previousLocalizationData: RawLocalizationDataType<TranslationKeys> =\n                    localization[previousLocalizationName];\n\n                if (isFetchingLocaleData && typeof previousLocalizationData !== \"function\") {\n                    return getLocalizedStringHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        previousLocalizationData,\n                        valueMap\n                    );\n                }\n\n                if (typeof existsLocalizationData !== \"function\") {\n                    return getLocalizedStringHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        existsLocalizationData,\n                        valueMap\n                    );\n                }\n\n                if (typeof previousLocalizationData !== \"function\") {\n                    return getLocalizedStringHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        previousLocalizationData,\n                        valueMap\n                    );\n                }\n\n                console.log(\"There is no localization data, return string\");\n\n                return placeholderText;\n            },\n            [localeName, isFetchingLocaleData]\n        );\n\n        const providedData: LocaleContextType<TranslationKeys, LocaleName> = useMemo((): LocaleContextType<\n            TranslationKeys,\n            LocaleName\n        > => {\n            return {\n                getLocalizedString,\n                isFetchingLocaleData,\n                localeName,\n                setLocaleName: memoizedSetLocaleName,\n            };\n        }, [localeName, memoizedSetLocaleName, getLocalizedString, isFetchingLocaleData]);\n\n        return <LocaleContext.Provider value={providedData}>{children}</LocaleContext.Provider>;\n    }\n\n    function Locale(props: LocalePropsType<TranslationKeys>): JSX.Element {\n        // eslint-disable-next-line react/prop-types\n        const {stringKey, valueMap = {}} = props;\n\n        const {localeName} = useContext<LocaleContextType<TranslationKeys, LocaleName>>(LocaleContext);\n\n        const existsLocalizationData: RawLocalizationDataType<TranslationKeys> = localization[localeName];\n        const previousLocalizationData: RawLocalizationDataType<TranslationKeys> =\n            localization[previousLocalizationName];\n\n        if (typeof existsLocalizationData !== \"function\") {\n            return (\n                <>\n                    {getLocalizedComponentHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        existsLocalizationData,\n                        valueMap\n                    )}\n                </>\n            );\n        }\n\n        if (typeof previousLocalizationData !== \"function\") {\n            return (\n                <>\n                    {getLocalizedComponentHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        previousLocalizationData,\n                        valueMap\n                    )}\n                </>\n            );\n        }\n\n        console.log(\"There is no localization data, return jsx\");\n\n        // eslint-disable-next-line react/jsx-no-useless-fragment\n        return <>{placeholderText}</>;\n    }\n\n    function useLocale(): LocaleContextType<TranslationKeys, LocaleName> {\n        return useContext<LocaleContextType<TranslationKeys, LocaleName>>(LocaleContext);\n    }\n\n    return {Locale, LocalizationProvider, useLocale};\n}\n","/* global setTimeout */\n\nexport async function waitForTime(timeInMilliseconds: number): Promise<void> {\n    return new Promise((resolve: () => void) => {\n        setTimeout(resolve, timeInMilliseconds);\n    });\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","splitValueStringRegExp","placeholderText","getLocalizedString","stringKey","localeName","localization","valueMap","resultString","rawString","keyList","keys","objectKey","replace","RegExp","replacePlaceholderMap","getLocalizedComponentHelper","partList","split","map","part","index","replacedPart","startsWith","endOfString","slice","length","_jsxs","Fragment","children","String","createLocalization","localizationConfig","defaultLocaleName","localizationArgument","onUseEffect","previousLocalizationName","defaultLocalizationData","toString","isFetchingLocaleData","setLocaleName","LocaleContext","createContext","Locale","props","useContext","existsLocalizationData","previousLocalizationData","_jsx","_Fragment","LocalizationProvider","forcedLocaleName","useState","setIsFetchingLocaleData","useEffect","trim","async","localizationData","fetchLocalizationData","then","timeInMilliseconds","Promise","resolve","setTimeout","waitForTime","finally","memoizedSetLocaleName","useCallback","updatedLocaleName","getLocalizedStringHelper","providedData","useMemo","Provider","useLocale"],"sourceRoot":""}