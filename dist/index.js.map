{"version":3,"file":"index.js","mappings":"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","sources":["webpack://react-localization-library/webpack/bootstrap","webpack://react-localization-library/webpack/runtime/define property getters","webpack://react-localization-library/webpack/runtime/hasOwnProperty shorthand","webpack://react-localization-library/webpack/runtime/make namespace object","webpack://react-localization-library/external commonjs \"react/jsx-runtime\"","webpack://react-localization-library/external commonjs \"react\"","webpack://react-localization-library/./www/library/src/localization-const.ts","webpack://react-localization-library/./www/library/src/localization-helper.tsx","webpack://react-localization-library/./www/library/src/localization.tsx","webpack://react-localization-library/./www/library/src/util/timer.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"react/jsx-runtime\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"react\");","export const splitValueStringRegExp = /(?={\\w+?})/g;\n\nexport const placeholderText = '_TEXT_';\n","import {Fragment, ReactNode} from 'react';\n\nimport {splitValueStringRegExp} from './localization-const';\nimport {\n    LocalizationDataType,\n    // LocalizationDataLoaderType,\n    LocalizationType,\n    RawLocalizationDataType,\n} from './localization-type';\n\nfunction replacePlaceholderMap(rawString: string, valueMap: Record<string, string>): string {\n    let resultString = rawString;\n\n    const keyList = Object.keys(valueMap);\n\n    // eslint-disable-next-line no-loops/no-loops\n    for (const objectKey of keyList) {\n        resultString = resultString.replace(new RegExp('{' + objectKey + '}', 'g'), valueMap[objectKey]);\n    }\n\n    return resultString;\n}\n\nexport function getLocalizedString<TranslationKeys extends string, LocaleName extends string>(\n    stringKey: TranslationKeys,\n    localeName: LocaleName,\n    localization: LocalizationDataType<TranslationKeys>,\n    valueMap?: Record<string, string>\n): string {\n    // const localizationData = localization[localeName];\n\n    // if (typeof localizationData === 'function') {\n    //     return 'TEXT';\n    // }\n\n    const resultString = localization[stringKey];\n\n    return valueMap ? replacePlaceholderMap(resultString, valueMap) : resultString;\n}\n\nexport function getLocalizedComponentHelper<TranslationKeys extends string, LocaleName extends string>(\n    stringKey: TranslationKeys,\n    localeName: LocaleName,\n    localization: LocalizationDataType<TranslationKeys>,\n    valueMap: Record<string, ReactNode>\n): Array<JSX.Element | string> {\n    const resultString = localization[stringKey]; // 'the {value1} data {value2} is {value2} here'\n\n    let partList: Array<JSX.Element | string> = resultString.split(splitValueStringRegExp); // [\"the \", \"{value1} data \", \"{value2} is \", \"{value2} here\"]\n\n    const keyList = Object.keys(valueMap);\n\n    // eslint-disable-next-line no-loops/no-loops\n    for (const objectKey of keyList) {\n        partList = partList.map((part: JSX.Element | string, index: number): JSX.Element | string => {\n            if (typeof part !== 'string') {\n                return part;\n            }\n\n            const replacedPart = '{' + objectKey + '}';\n\n            if (!part.startsWith(replacedPart)) {\n                return part;\n            }\n\n            const endOfString = part.slice(replacedPart.length);\n\n            return (\n                <Fragment key={String(objectKey + '-' + index)}>\n                    {valueMap[objectKey]}\n                    {endOfString}\n                </Fragment>\n            );\n        });\n    }\n\n    return partList;\n}\n\nexport function fetchLocalizationData<LocaleName extends string, TranslationKeys extends string>(\n    localeName: LocaleName,\n    localization: LocalizationType<LocaleName, TranslationKeys>\n): Promise<LocalizationDataType<TranslationKeys>> {\n    const localizationData: RawLocalizationDataType<TranslationKeys> = localization[localeName];\n\n    if (typeof localizationData === 'function') {\n        return localizationData();\n    }\n\n    return Promise.resolve(localizationData);\n}\n","/* eslint-disable react/no-multi-comp */\nimport {Context, createContext, useCallback, useContext, useEffect, useMemo, useState} from 'react';\n\nimport {\n    LocaleContextType,\n    LocalePropsType,\n    LocalizationConfigType,\n    LocalizationLibraryType,\n    ProviderPropsType,\n} from '../library';\n\nimport {\n    fetchLocalizationData,\n    getLocalizedComponentHelper,\n    getLocalizedString as getLocalizedStringHelper,\n} from './localization-helper';\nimport {\n    LocalizationDataType,\n    // LocalizationDataLoaderType,\n    LocalizationType,\n    RawLocalizationDataType,\n} from './localization-type';\nimport {placeholderText} from './localization-const';\nimport {waitForTime} from './util/timer';\n\nexport function createLocalization<TranslationKeys extends string, LocaleName extends string>(\n    localizationConfig: LocalizationConfigType<TranslationKeys, LocaleName>\n): LocalizationLibraryType<TranslationKeys, LocaleName> {\n    const {defaultLocaleName, localization: localizationArgument, onUseEffect = () => null} = localizationConfig;\n    let previousLocalizationName: LocaleName = defaultLocaleName;\n\n    const localization: LocalizationType<LocaleName, TranslationKeys> = {...localizationArgument};\n\n    // for (const key in localization) {\n    //     const localizationData: LocalizationDataType<TranslationKeys> | LocalizationDataLoaderType<TranslationKeys> = localization[key];\n    //\n    //     localeNameMap[key] = typeof localizationData !== 'function' ? null : localizationData;\n    // }\n\n    // const localizationMap: Record<LocaleName, null> = Object.fromEntries<Record<LocaleName, null>>(localeNameList);\n\n    // console.log(localeNameList, localizationMap);\n\n    // const localizationMap: Record<LocaleName, null> = Object\n    //     .fromEntries<null>(Object.keys(localization).map((key: LocaleName) => [key, null]))\n\n    const defaultLocalizationData: LocaleContextType<TranslationKeys, LocaleName> = {\n        getLocalizedString: String.toString,\n        isFetchingLocaleData: typeof localization[defaultLocaleName] === 'function',\n        localeName: defaultLocaleName,\n        setLocaleName: String.toString,\n    };\n\n    const LocaleContext: Context<LocaleContextType<TranslationKeys, LocaleName>> =\n        createContext<LocaleContextType<TranslationKeys, LocaleName>>(defaultLocalizationData);\n\n    function LocalizationProvider(props: ProviderPropsType): JSX.Element {\n        const {children} = props;\n\n        const [localeName, setLocaleName] = useState<LocaleName>(defaultLocalizationData.localeName);\n        const [isFetchingLocaleData, setIsFetchingLocaleData] = useState<boolean>(\n            defaultLocalizationData.isFetchingLocaleData\n        );\n\n        useEffect(() => {\n            const existsLocalizationData: RawLocalizationDataType<TranslationKeys> = localization[localeName];\n\n            // check localization data already exists\n            if (typeof existsLocalizationData !== 'function') {\n                previousLocalizationName = localeName;\n                onUseEffect({isFetchingLocaleData: false, localeName});\n                return;\n            }\n\n            setIsFetchingLocaleData(true);\n            onUseEffect({isFetchingLocaleData: true, localeName: previousLocalizationName});\n\n            // eslint-disable-next-line promise/catch-or-return\n            fetchLocalizationData<LocaleName, TranslationKeys>(localeName, localization)\n                .then((localizationData: LocalizationDataType<TranslationKeys>) => {\n                    // Make sure that React's circle is updated\n                    // needed to update async locale\n                    // eslint-disable-next-line promise/no-nesting\n                    return waitForTime(0).then(() => {\n                        localization[localeName] = localizationData;\n                        previousLocalizationName = localeName;\n\n                        onUseEffect({isFetchingLocaleData: false, localeName});\n                    });\n                })\n                .finally((): void => {\n                    setIsFetchingLocaleData(false);\n                });\n        }, [localeName, setIsFetchingLocaleData]);\n\n        const memoizedSetLocaleName = useCallback(\n            (newLocaleName: LocaleName) => {\n                if (isFetchingLocaleData) {\n                    console.log('do not change locale name while localizing data loading');\n                    return;\n                }\n                setLocaleName(newLocaleName);\n            },\n            [isFetchingLocaleData]\n        );\n\n        const getLocalizedString = useCallback(\n            (stringKey: TranslationKeys, valueMap?: Record<string, string>): string => {\n                const existsLocalizationData: RawLocalizationDataType<TranslationKeys> = localization[localeName];\n                const previousLocalizationData: RawLocalizationDataType<TranslationKeys> =\n                    localization[previousLocalizationName];\n\n                if (isFetchingLocaleData && typeof previousLocalizationData !== 'function') {\n                    return getLocalizedStringHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        previousLocalizationData,\n                        valueMap\n                    );\n                }\n\n                if (typeof existsLocalizationData !== 'function') {\n                    return getLocalizedStringHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        existsLocalizationData,\n                        valueMap\n                    );\n                }\n\n                if (typeof previousLocalizationData !== 'function') {\n                    return getLocalizedStringHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        previousLocalizationData,\n                        valueMap\n                    );\n                }\n\n                console.log('There is no localization data, return string');\n\n                return placeholderText;\n            },\n            [localeName, isFetchingLocaleData]\n        );\n\n        const providedData: LocaleContextType<TranslationKeys, LocaleName> = useMemo((): LocaleContextType<\n            TranslationKeys,\n            LocaleName\n        > => {\n            return {\n                getLocalizedString,\n                isFetchingLocaleData,\n                localeName,\n                setLocaleName: memoizedSetLocaleName,\n            };\n        }, [localeName, memoizedSetLocaleName, getLocalizedString, isFetchingLocaleData]);\n\n        return <LocaleContext.Provider value={providedData}>{children}</LocaleContext.Provider>;\n    }\n\n    function Locale(props: LocalePropsType<TranslationKeys>): JSX.Element {\n        // eslint-disable-next-line react/prop-types\n        const {stringKey, valueMap = {}} = props;\n\n        const {localeName} = useContext<LocaleContextType<TranslationKeys, LocaleName>>(LocaleContext);\n\n        const existsLocalizationData: RawLocalizationDataType<TranslationKeys> = localization[localeName];\n        const previousLocalizationData: RawLocalizationDataType<TranslationKeys> =\n            localization[previousLocalizationName];\n\n        if (typeof existsLocalizationData !== 'function') {\n            return (\n                <>\n                    {getLocalizedComponentHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        existsLocalizationData,\n                        valueMap\n                    )}\n                </>\n            );\n        }\n\n        if (typeof previousLocalizationData !== 'function') {\n            return (\n                <>\n                    {getLocalizedComponentHelper<TranslationKeys, LocaleName>(\n                        stringKey,\n                        localeName,\n                        previousLocalizationData,\n                        valueMap\n                    )}\n                </>\n            );\n        }\n\n        console.log('There is no localization data, return jsx');\n\n        // eslint-disable-next-line react/jsx-no-useless-fragment\n        return <>{placeholderText}</>;\n    }\n\n    function useLocale(): LocaleContextType<TranslationKeys, LocaleName> {\n        return useContext<LocaleContextType<TranslationKeys, LocaleName>>(LocaleContext);\n    }\n\n    return {Locale, LocalizationProvider, useLocale};\n}\n","/* global setTimeout */\n\nexport function waitForTime(timeInMilliseconds: number): Promise<void> {\n    return new Promise((resolve: () => void) => {\n        setTimeout(resolve, timeInMilliseconds);\n    });\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","splitValueStringRegExp","placeholderText","stringKey","localeName","localization","valueMap","resultString","rawString","keyList","keys","objectKey","replace","RegExp","replacePlaceholderMap","getLocalizedComponentHelper","partList","split","map","part","index","replacedPart","startsWith","endOfString","slice","length","Fragment","String","createLocalization","localizationConfig","defaultLocaleName","localizationArgument","onUseEffect","previousLocalizationName","defaultLocalizationData","getLocalizedString","toString","isFetchingLocaleData","setLocaleName","LocaleContext","createContext","Locale","props","useContext","existsLocalizationData","previousLocalizationData","LocalizationProvider","children","useState","setIsFetchingLocaleData","useEffect","localizationData","Promise","resolve","fetchLocalizationData","then","setTimeout","finally","memoizedSetLocaleName","useCallback","newLocaleName","providedData","useMemo","Provider","useLocale"],"sourceRoot":""}